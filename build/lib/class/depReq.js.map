{
  "version": 3,
  "sources": ["../../../src/lib/class/depReq.ts"],
  "sourcesContent": ["import type { TTAdapter } from '../../main';\nimport { defaultFolder, genericStateObjects } from '../const/definition';\nimport { BaseClass } from '../tools/library';\nimport { mapDeparturesToDepartureStates } from '../tools/mapper';\nimport { defaultDepartureOpt, type DeparturesResponse } from '../types/types';\n\nexport class DepartureRequest extends BaseClass {\n    response: DeparturesResponse;\n    constructor(adapter: TTAdapter) {\n        super(adapter);\n        this.response = {} as DeparturesResponse;\n    }\n    /**\n     *  Ruft Abfahrten f\u00FCr eine gegebene stationId ab und schreibt sie in die States.\n     *\n     * @param stationId     Die ID der Station, f\u00FCr die Abfahrten abgefragt werden sollen.\n     * @param options      Zus\u00E4tzliche Optionen f\u00FCr die Abfrage.\n     */\n    public async getDepartures(stationId: string, options: any = {}): Promise<void> {\n        try {\n            if (!stationId) {\n                throw new Error('Keine stationId \u00FCbergeben');\n            }\n            const hService = this.adapter.hService;\n            const mergedOptions = { ...defaultDepartureOpt, ...options };\n            // Antwort von HAFAS als vollst\u00E4ndiger Typ\n            this.response = await hService.getDepartures(stationId, mergedOptions);\n            // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n            this.adapter.log.info(JSON.stringify(this.response.departures, null, 1));\n            // Stations Ordner erstellen\n            await this.library.writedp(`${this.adapter.namespace}.${stationId}`, undefined, defaultFolder);\n            // Konvertiere zu reduzierten States\n            const departureStates = mapDeparturesToDepartureStates(this.response.departures);\n            // Vor dem Schreiben alte States l\u00F6schen\n            await this.library.cleanUpTree([`${this.adapter.namespace}.${stationId}`], null, 1);\n            // JSON in die States schreiben\n            await this.library.writeFromJson(\n                `${this.adapter.namespace}.${stationId}.`,\n                'departures',\n                genericStateObjects,\n                departureStates,\n                true,\n            );\n        } catch (error) {\n            this.log.error(`Fehler bei der Abfrage der Abfahrten: ${(error as Error).message}`);\n            throw error;\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAAmD;AACnD,qBAA0B;AAC1B,oBAA+C;AAC/C,mBAA6D;AAEtD,MAAM,yBAAyB,yBAAU;AAAA,EAC5C;AAAA,EACA,YAAY,SAAoB;AAC5B,UAAM,OAAO;AACb,SAAK,WAAW,CAAC;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,cAAc,WAAmB,UAAe,CAAC,GAAkB;AAC5E,QAAI;AACA,UAAI,CAAC,WAAW;AACZ,cAAM,IAAI,MAAM,8BAA2B;AAAA,MAC/C;AACA,YAAM,WAAW,KAAK,QAAQ;AAC9B,YAAM,gBAAgB,EAAE,GAAG,kCAAqB,GAAG,QAAQ;AAE3D,WAAK,WAAW,MAAM,SAAS,cAAc,WAAW,aAAa;AAErE,WAAK,QAAQ,IAAI,KAAK,KAAK,UAAU,KAAK,SAAS,YAAY,MAAM,CAAC,CAAC;AAEvE,YAAM,KAAK,QAAQ,QAAQ,GAAG,KAAK,QAAQ,SAAS,IAAI,SAAS,IAAI,QAAW,+BAAa;AAE7F,YAAM,sBAAkB,8CAA+B,KAAK,SAAS,UAAU;AAE/E,YAAM,KAAK,QAAQ,YAAY,CAAC,GAAG,KAAK,QAAQ,SAAS,IAAI,SAAS,EAAE,GAAG,MAAM,CAAC;AAElF,YAAM,KAAK,QAAQ;AAAA,QACf,GAAG,KAAK,QAAQ,SAAS,IAAI,SAAS;AAAA,QACtC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,SAAS,OAAO;AACZ,WAAK,IAAI,MAAM,yCAA0C,MAAgB,OAAO,EAAE;AAClF,YAAM;AAAA,IACV;AAAA,EACJ;AACJ;",
  "names": []
}
