{
  "version": 3,
  "sources": ["../../../src/lib/class/depReq.ts"],
  "sourcesContent": ["import type * as Hafas from 'hafas-client';\nimport type { TTAdapter } from '../../main';\nimport { defaultFolder, genericStateObjects } from '../const/definition';\nimport { BaseClass } from '../tools/library';\nimport { mapDeparturesToDepartureStates } from '../tools/mapper';\nimport { defaultDepartureOpt, type Departure, type DeparturesResponse, type Products } from '../types/types';\n\nexport class DepartureRequest extends BaseClass {\n    response: DeparturesResponse;\n    constructor(adapter: TTAdapter) {\n        super(adapter);\n        this.response = {} as DeparturesResponse;\n        this.log.setLogPrefix('depReq');\n    }\n    /**\n     *  Ruft Abfahrten f\u00FCr eine gegebene stationId ab und schreibt sie in die States.\n     *\n     * @param stationId     Die ID der Station, f\u00FCr die Abfahrten abgefragt werden sollen.\n     * @param service      Der Service f\u00FCr die Abfrage.\n     * @param options      Zus\u00E4tzliche Optionen f\u00FCr die Abfrage.\n     * @param products    Die aktivierten Produkte (true = erlaubt)\n     */\n    public async getDepartures(\n        stationId: string,\n        service: any,\n        options: Hafas.DeparturesArrivalsOptions = {},\n        products?: Partial<Products>,\n    ): Promise<boolean> {\n        try {\n            if (!stationId) {\n                throw new Error('Keine stationId \u00FCbergeben');\n            }\n            const mergedOptions = { ...defaultDepartureOpt, ...options };\n            // Antwort von HAFAS als vollst\u00E4ndiger Typ\n            this.response = await service.getDepartures(stationId, mergedOptions);\n            // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n            this.adapter.log.debug(JSON.stringify(this.response.departures, null, 1));\n            // Stations Ordner erstellen\n            await this.library.writedp(\n                `${this.adapter.namespace}.Stations.${stationId}.Departures`,\n                undefined,\n                defaultFolder,\n            );\n            // Filtere nach Produkten, falls angegeben\n            if (products) {\n                this.response.departures = this.filterByProducts(this.response.departures, products);\n            }\n            // Konvertiere zu reduzierten States\n            const departureStates = mapDeparturesToDepartureStates(this.response.departures);\n            // Vor dem Schreiben alte States l\u00F6schen\n            await this.library.garbageColleting(`${this.adapter.namespace}.Stations.${stationId}.Departures.`, 2000);\n            // JSON in die States schreiben\n            await this.library.writeFromJson(\n                `${this.adapter.namespace}.Stations.${stationId}.Departures.`,\n                'departures',\n                genericStateObjects,\n                departureStates,\n                true,\n            );\n            //await this.getStop(stationId, service);\n            return true;\n        } catch (error) {\n            this.log.error(\n                `Fehler bei der Abfrage der Abfahrten f\u00FCr Station ${stationId}: ${(error as Error).message}`,\n            );\n            return false;\n        }\n    }\n\n    private async getStop(\n        stationId: string,\n        service: any,\n        options?: Hafas.StopOptions,\n    ): Promise<Hafas.Station | Hafas.Stop | Hafas.Location> {\n        if (!stationId) {\n            throw new Error('Keine stationId \u00FCbergeben');\n        }\n        if (!service) {\n            throw new Error('Kein Service \u00FCbergeben');\n        }\n        const stop = await service.getStop(stationId, options);\n        // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n        this.adapter.log.debug(JSON.stringify(stop, null, 1));\n        // JSON in die States schreiben\n        await this.library.writeFromJson(\n            `${this.adapter.namespace}.Stations.${stationId}.`,\n            'departures',\n            genericStateObjects,\n            stop,\n            true,\n        );\n        return stop;\n    }\n\n    /**\n     * Filtert Abfahrten nach den gew\u00E4hlten Produkten.\n     * Es werden nur Abfahrten zur\u00FCckgegeben, deren Produkt in den aktivierten Produkten enthalten ist.\n     *\n     * @param departures    Die zu filternden Abfahrten\n     * @param products      Die aktivierten Produkte (true = erlaubt)\n     * @returns             Gefilterte Abfahrten\n     */\n    filterByProducts(departures: Departure[], products: Partial<Products>): Departure[] {\n        // Erstelle eine Liste der aktivierten Produktnamen\n        const enabledProducts = Object.entries(products)\n            .filter(([_, enabled]) => enabled === true)\n            .map(([productName, _]) => productName);\n\n        // Wenn keine Produkte aktiviert sind, gib alle zur\u00FCck\n        if (enabledProducts.length === 0) {\n            return departures;\n        }\n\n        // Filtere Abfahrten: behalte nur die, deren line.product in enabledProducts ist\n        return departures.filter(departure => {\n            const lineProduct = departure.line?.product;\n            if (!lineProduct) {\n                this.log.info(\n                    `Abfahrt ${departure.line?.name || 'unbekannt'} Richtung ${departure.direction} gefiltert: Keine Produktinfo vorhanden`,\n                );\n                return false;\n            }\n            const isEnabled = enabledProducts.includes(lineProduct);\n            if (!isEnabled) {\n                this.log.info(\n                    `Abfahrt ${departure.line?.name} Richtung ${departure.direction} gefiltert: Produkt \"${lineProduct}\" nicht aktiviert`,\n                );\n            }\n            return isEnabled;\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
