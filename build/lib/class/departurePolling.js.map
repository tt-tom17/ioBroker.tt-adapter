{
  "version": 3,
  "sources": ["../../../src/lib/class/departurePolling.ts"],
  "sourcesContent": ["import type { PublicTransport } from '../../main';\nimport type { ITransportService } from '../types/transportService';\nimport { PollingManager } from './pollingManager';\n\ninterface DepartureConfig {\n    id: string;\n    enabled: boolean;\n    customName?: string;\n    name?: string;\n    offsetTime?: number;\n    duration?: number;\n    numDepartures?: number;\n    products?: any;\n}\n\nexport class DeparturePolling extends PollingManager<DepartureConfig> {\n    constructor(adapter: PublicTransport) {\n        super(adapter);\n    }\n\n    /**\n     * Erstellt die Optionen f\u00FCr eine Abfahrtsanfrage.\n     *\n     * @param config Die Station-Konfiguration\n     * @returns Die Optionen f\u00FCr die Abfrage\n     */\n    private createDepartureOptions(config: DepartureConfig): { results: number; when?: Date; duration: number } {\n        const offsetTime = config.offsetTime ?? 0;\n        const when: Date | undefined = offsetTime === 0 ? undefined : new Date(Date.now() + offsetTime * 60 * 1000);\n        const duration = config.duration ?? 10;\n        const results = config.numDepartures ?? 10;\n\n        return { results, when, duration };\n    }\n\n    /**\n     * F\u00FChrt die Abfrage f\u00FCr eine Station durch.\n     *\n     * @param config Die Station-Konfiguration\n     * @param service Der Transport-Service\n     * @returns true wenn erfolgreich, false sonst\n     */\n    protected async queryConfig(config: DepartureConfig, service: ITransportService): Promise<boolean> {\n        const options = this.createDepartureOptions(config);\n        const products = config.products ?? undefined;\n        const countEntries = config.numDepartures ?? 10;\n\n        return await this.adapter.depRequest.getDepartures(config.id, service, options, countEntries, products);\n    }\n\n    /**\n     * Startet das Polling f\u00FCr Abfahrten.\n     *\n     * @param pollIntervalMinutes Das Polling-Intervall in Minuten\n     */\n    public async startDepartures(pollIntervalMinutes: number): Promise<void> {\n        await this.start(this.adapter.config.stationConfig as DepartureConfig[], pollIntervalMinutes, {\n            noConfig: 'msg_noStationsConfigured',\n            noEnabled: 'msg_noEnabledStations',\n            count: 'msg_activeStationsFound',\n            entry: 'msg_stationListEntry',\n            fetching: 'msg_fetchingDepartures',\n            updated: 'msg_departuresUpdated',\n            failed: 'msg_departuresUpdateFailed',\n            firstCompleted: 'msg_firstQueryCompleted',\n            queryCompleted: 'msg_queryCompleted',\n            waiting: 'msg_waitingForNextQuery',\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,4BAA+B;AAaxB,MAAM,yBAAyB,qCAAgC;AAAA,EAClE,YAAY,SAA0B;AAClC,UAAM,OAAO;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,uBAAuB,QAA6E;AA1BhH;AA2BQ,UAAM,cAAa,YAAO,eAAP,YAAqB;AACxC,UAAM,OAAyB,eAAe,IAAI,SAAY,IAAI,KAAK,KAAK,IAAI,IAAI,aAAa,KAAK,GAAI;AAC1G,UAAM,YAAW,YAAO,aAAP,YAAmB;AACpC,UAAM,WAAU,YAAO,kBAAP,YAAwB;AAExC,WAAO,EAAE,SAAS,MAAM,SAAS;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAgB,YAAY,QAAyB,SAA8C;AA1CvG;AA2CQ,UAAM,UAAU,KAAK,uBAAuB,MAAM;AAClD,UAAM,YAAW,YAAO,aAAP,YAAmB;AACpC,UAAM,gBAAe,YAAO,kBAAP,YAAwB;AAE7C,WAAO,MAAM,KAAK,QAAQ,WAAW,cAAc,OAAO,IAAI,SAAS,SAAS,cAAc,QAAQ;AAAA,EAC1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,gBAAgB,qBAA4C;AACrE,UAAM,KAAK,MAAM,KAAK,QAAQ,OAAO,eAAoC,qBAAqB;AAAA,MAC1F,UAAU;AAAA,MACV,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,MACP,UAAU;AAAA,MACV,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,MAChB,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AACJ;",
  "names": []
}
