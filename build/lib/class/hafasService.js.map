{
  "version": 3,
  "sources": ["../../../src/lib/class/hafasService.ts"],
  "sourcesContent": ["/**\n * HafasService - kleiner Wrapper um `hafas-client`.\n *\n * Kapselt die Client-Erzeugung und bietet einfache asynchrone Methoden\n * f\u00FCr `locations` und `departures` an.\n */\nimport type {\n    Departures,\n    DeparturesArrivalsOptions,\n    Journeys,\n    JourneysOptions,\n    Location,\n    LocationsOptions,\n    Station,\n    Stop,\n} from 'hafas-client';\nimport { createClient as hafasClient } from 'hafas-client';\nimport { profile as vbbProfile } from 'hafas-client/p/vbb/index.js';\nimport type { ITransportService } from '../types/transportService';\n\nexport class HafasService implements ITransportService {\n    private client: ReturnType<typeof hafasClient> | null = null;\n    private clientName: string;\n    private profileName: string;\n\n    /**\n     * Erzeugt eine neue Instanz des HafasService.\n     * Der Client wird erst durch Aufruf von `init()` erstellt.\n     *\n     * @param clientName Name, der an den Client \u00FCbergeben wird\n     * @param profileName Name des HAFAS-Profils ('vbb', 'db', etc.)\n     */\n    constructor(clientName: string, profileName: string) {\n        this.clientName = clientName;\n        this.profileName = profileName;\n    }\n\n    /**\n     * Initialisiert den HAFAS-Client.\n     * Muss vor der Nutzung der anderen Methoden aufgerufen werden.\n     *\n     * @returns true bei Erfolg, false bei Fehler\n     */\n    public init(): boolean {\n        try {\n            const profile = this.resolveProfile(this.profileName);\n            this.client = hafasClient(profile, this.clientName);\n            return true;\n        } catch (error) {\n            throw new Error(`HAFAS-Client konnte nicht initialisiert werden: ${(error as Error).message}`);\n        }\n    }\n\n    /**\n     * Pr\u00FCft ob der Client initialisiert wurde.\n     */\n    public isInitialized(): boolean {\n        return this.client !== null;\n    }\n\n    /**\n     * Gibt den initialisierten Client zur\u00FCck oder wirft einen Fehler.\n     */\n    private getClient(): ReturnType<typeof hafasClient> {\n        if (!this.client) {\n            throw new Error('HafasService wurde noch nicht initialisiert. Bitte zuerst init() aufrufen.');\n        }\n        return this.client;\n    }\n\n    /**\n     * Resolve a profile given either a ProfileName or a profile object.\n     * Falls `profile` leer ist, wird `vbbProfile` verwendet.\n     *\n     * @param profile entweder ein Eintrag aus `ProfileName` oder ein Profil-Objekt\n     * @returns das aufgel\u00F6ste Profil-Objekt\n     */\n    private resolveProfile(profile?: string): any {\n        if (!profile) {\n            return vbbProfile;\n        }\n\n        switch (profile) {\n            case 'vbb': {\n                return vbbProfile;\n            }\n            default: {\n                throw new Error(`Unbekanntes Profile: ${String(profile)}. Verf\u00FCgbare Profile: 'vbb'.`);\n            }\n        }\n    }\n\n    /**\n     * Suche nach Orten/Stationen.\n     *\n     * @param query Suchbegriff f\u00FCr Orte/Stationen\n     * @param options optionale Suchoptionen\n     * @returns Promise mit Suchergebnissen (typisiert als any)\n     */\n    async getLocations(query: string, options?: LocationsOptions): Promise<ReadonlyArray<Station | Stop | Location>> {\n        return this.getClient().locations(query, options);\n    }\n\n    /**\n     * Liefert Abfahrten f\u00FCr eine gegebene Stations-ID.\n     *\n     * @param stationId ID der Station\n     * @param options optionale Abfrage-Optionen\n     * @returns Promise mit Abfahrtsinformationen (typisiert als any)\n     */\n    async getDepartures(stationId: string, options?: DeparturesArrivalsOptions): Promise<Departures> {\n        return this.getClient().departures(stationId, options);\n    }\n\n    /**\n     * Liefert Routeninformationen zwischen zwei Stationen.\n     *\n     * @param fromId ID der Startstation\n     * @param toId ID der Zielstation\n     * @param options optionale Routen-Optionen\n     * @returns Promise mit Routeninformationen (typisiert als any)\n     */\n    async getRoute(fromId: string, toId: string, options?: JourneysOptions): Promise<Journeys> {\n        return this.getClient().journeys(fromId, toId, options);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,0BAA4C;AAC5C,iBAAsC;AAG/B,MAAM,aAA0C;AAAA,EAC3C,SAAgD;AAAA,EAChD;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASR,YAAY,YAAoB,aAAqB;AACjD,SAAK,aAAa;AAClB,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,OAAgB;AACnB,QAAI;AACA,YAAM,UAAU,KAAK,eAAe,KAAK,WAAW;AACpD,WAAK,aAAS,oBAAAA,cAAY,SAAS,KAAK,UAAU;AAClD,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,YAAM,IAAI,MAAM,mDAAoD,MAAgB,OAAO,EAAE;AAAA,IACjG;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKO,gBAAyB;AAC5B,WAAO,KAAK,WAAW;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKQ,YAA4C;AAChD,QAAI,CAAC,KAAK,QAAQ;AACd,YAAM,IAAI,MAAM,4EAA4E;AAAA,IAChG;AACA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,eAAe,SAAuB;AAC1C,QAAI,CAAC,SAAS;AACV,aAAO,WAAAC;AAAA,IACX;AAEA,YAAQ,SAAS;AAAA,MACb,KAAK,OAAO;AACR,eAAO,WAAAA;AAAA,MACX;AAAA,MACA,SAAS;AACL,cAAM,IAAI,MAAM,wBAAwB,OAAO,OAAO,CAAC,iCAA8B;AAAA,MACzF;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,aAAa,OAAe,SAA+E;AAC7G,WAAO,KAAK,UAAU,EAAE,UAAU,OAAO,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,cAAc,WAAmB,SAA0D;AAC7F,WAAO,KAAK,UAAU,EAAE,WAAW,WAAW,OAAO;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,SAAS,QAAgB,MAAc,SAA8C;AACvF,WAAO,KAAK,UAAU,EAAE,SAAS,QAAQ,MAAM,OAAO;AAAA,EAC1D;AACJ;",
  "names": ["hafasClient", "vbbProfile"]
}
