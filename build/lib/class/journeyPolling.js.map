{
  "version": 3,
  "sources": ["../../../src/lib/class/journeyPolling.ts"],
  "sourcesContent": ["import type * as Hafas from 'hafas-client';\nimport type { TTAdapter } from '../../main';\nimport type { ITransportService } from '../types/transportService';\nimport { PollingManager } from './pollingManager';\n\ninterface JourneyConfig {\n    id: string;\n    customName: string;\n    enabled: boolean;\n    numResults?: number;\n    fromStationId: string;\n    fromStationName: string;\n    toStationId: string;\n    toStationName: string;\n    departure?: string;\n    arrival?: string;\n    via?: string;\n    stopovers?: boolean;\n    transfers?: number;\n    transferTime?: number;\n    accessibility?: 'partial' | 'complete';\n    bike?: boolean;\n    products?: Partial<ioBroker.Products>;\n}\n\nexport class JourneyPolling extends PollingManager<JourneyConfig> {\n    constructor(adapter: TTAdapter) {\n        super(adapter);\n    }\n\n    /**\n     * Erstellt die Optionen f\u00FCr eine Journey-Anfrage.\n     *\n     * @param config Die Journey-Konfiguration\n     * @returns Die Optionen f\u00FCr die Abfrage\n     */\n    private createJourneyOptions(config: JourneyConfig): Hafas.JourneysOptions {\n        const options: Hafas.JourneysOptions = {\n            results: config.numResults ?? 5,\n            stopovers: config.stopovers ?? false,\n        };\n\n        if (config.departure) {\n            options.departure = new Date(config.departure);\n        }\n\n        if (config.arrival) {\n            options.arrival = new Date(config.arrival);\n        }\n\n        if (config.via) {\n            options.via = config.via;\n        }\n\n        if (config.transfers !== undefined) {\n            options.transfers = config.transfers;\n        }\n\n        if (config.transferTime !== undefined) {\n            options.transferTime = config.transferTime;\n        }\n\n        if (config.accessibility) {\n            options.accessibility = config.accessibility;\n        }\n\n        if (config.bike !== undefined) {\n            options.bike = config.bike;\n        }\n\n        if (config.products) {\n            options.products = config.products;\n        }\n\n        return options;\n    }\n\n    /**\n     * F\u00FChrt die Abfrage f\u00FCr eine Journey durch.\n     *\n     * @param config Die Journey-Konfiguration\n     * @param service Der Transport-Service\n     * @returns true wenn erfolgreich, false sonst\n     */\n    protected async queryConfig(config: JourneyConfig, service: ITransportService): Promise<boolean> {\n        if (!config.fromStationId || !config.toStationId) {\n            this.adapter.log.warn(this.adapter.library.translate('msg_journeyNoFromTo', config.customName || ''));\n            return false;\n        }\n\n        const options = this.createJourneyOptions(config);\n\n        try {\n            return await this.adapter.journeysRequest.getJourneys(\n                config.id,\n                config.fromStationId,\n                config.toStationId,\n                service,\n                options,\n            );\n        } catch (error) {\n            this.adapter.log.error(\n                this.adapter.library.translate(\n                    'msg_journeyQueryFailed',\n                    config.customName || '',\n                    (error as Error).message,\n                ),\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Startet das Polling f\u00FCr Journeys.\n     *\n     * @param pollIntervalMinutes Das Polling-Intervall in Minuten\n     */\n    public async startJourneys(pollIntervalMinutes: number): Promise<void> {\n        await this.start(this.adapter.config.journeyConfig as JourneyConfig[], pollIntervalMinutes, {\n            noConfig: 'msg_noJourneysConfigured',\n            noEnabled: 'msg_noEnabledJourneysFound',\n            count: 'msg_activeJourneysFound',\n            entry: 'msg_journeyListEntry',\n            fetching: 'msg_fetchingJourneys',\n            updated: 'msg_journeysUpdated',\n            failed: 'msg_journeysUpdateFailed',\n            firstCompleted: 'msg_firstJourneyQueryCompleted',\n            queryCompleted: 'msg_journeyQueryCompleted',\n            waiting: 'msg_waitingForNextJourneyQuery',\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,4BAA+B;AAsBxB,MAAM,uBAAuB,qCAA8B;AAAA,EAC9D,YAAY,SAAoB;AAC5B,UAAM,OAAO;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,qBAAqB,QAA8C;AApC/E;AAqCQ,UAAM,UAAiC;AAAA,MACnC,UAAS,YAAO,eAAP,YAAqB;AAAA,MAC9B,YAAW,YAAO,cAAP,YAAoB;AAAA,IACnC;AAEA,QAAI,OAAO,WAAW;AAClB,cAAQ,YAAY,IAAI,KAAK,OAAO,SAAS;AAAA,IACjD;AAEA,QAAI,OAAO,SAAS;AAChB,cAAQ,UAAU,IAAI,KAAK,OAAO,OAAO;AAAA,IAC7C;AAEA,QAAI,OAAO,KAAK;AACZ,cAAQ,MAAM,OAAO;AAAA,IACzB;AAEA,QAAI,OAAO,cAAc,QAAW;AAChC,cAAQ,YAAY,OAAO;AAAA,IAC/B;AAEA,QAAI,OAAO,iBAAiB,QAAW;AACnC,cAAQ,eAAe,OAAO;AAAA,IAClC;AAEA,QAAI,OAAO,eAAe;AACtB,cAAQ,gBAAgB,OAAO;AAAA,IACnC;AAEA,QAAI,OAAO,SAAS,QAAW;AAC3B,cAAQ,OAAO,OAAO;AAAA,IAC1B;AAEA,QAAI,OAAO,UAAU;AACjB,cAAQ,WAAW,OAAO;AAAA,IAC9B;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAgB,YAAY,QAAuB,SAA8C;AAC7F,QAAI,CAAC,OAAO,iBAAiB,CAAC,OAAO,aAAa;AAC9C,WAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,QAAQ,UAAU,uBAAuB,OAAO,cAAc,EAAE,CAAC;AACpG,aAAO;AAAA,IACX;AAEA,UAAM,UAAU,KAAK,qBAAqB,MAAM;AAEhD,QAAI;AACA,aAAO,MAAM,KAAK,QAAQ,gBAAgB;AAAA,QACtC,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,SAAS,OAAO;AACZ,WAAK,QAAQ,IAAI;AAAA,QACb,KAAK,QAAQ,QAAQ;AAAA,UACjB;AAAA,UACA,OAAO,cAAc;AAAA,UACpB,MAAgB;AAAA,QACrB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,cAAc,qBAA4C;AACnE,UAAM,KAAK,MAAM,KAAK,QAAQ,OAAO,eAAkC,qBAAqB;AAAA,MACxF,UAAU;AAAA,MACV,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,MACP,UAAU;AAAA,MACV,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,MAChB,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AACJ;",
  "names": []
}
