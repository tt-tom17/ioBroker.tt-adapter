{
  "version": 3,
  "sources": ["../../../src/lib/class/pollingManager.ts"],
  "sourcesContent": ["import type { TTAdapter } from '../../main';\nimport type { ITransportService } from '../types/transportService';\n\ninterface PollingConfig {\n    id: string;\n    enabled: boolean;\n    customName?: string;\n    name?: string;\n    [key: string]: any;\n}\n\nexport abstract class PollingManager<T extends PollingConfig> {\n    protected adapter: TTAdapter;\n    private pollInterval: ioBroker.Interval | undefined;\n\n    constructor(adapter: TTAdapter) {\n        this.adapter = adapter;\n    }\n\n    /**\n     * Gibt die aktivierten Konfigurationen zur\u00FCck.\n     *\n     * @param configs Die Konfigurationen\n     * @param noConfigMsg Der \u00DCbersetzungsschl\u00FCssel wenn keine Konfigurationen vorhanden sind\n     * @param noEnabledMsg Der \u00DCbersetzungsschl\u00FCssel wenn keine aktivierten Konfigurationen vorhanden sind\n     * @returns Die aktivierten Konfigurationen oder undefined\n     */\n    protected getEnabledConfigs(configs: T[] | undefined, noConfigMsg: string, noEnabledMsg: string): T[] | undefined {\n        if (!configs || configs.length === 0) {\n            this.adapter.log.debug(this.adapter.library.translate(noConfigMsg));\n            return undefined;\n        }\n\n        const enabledConfigs = configs.filter(config => config.enabled);\n\n        if (enabledConfigs.length === 0) {\n            this.adapter.log.debug(this.adapter.library.translate(noEnabledMsg));\n            return undefined;\n        }\n\n        return enabledConfigs;\n    }\n\n    /**\n     * Loggt die gefundenen Konfigurationen.\n     *\n     * @param configs Die Konfigurationen\n     * @param countMsg Der \u00DCbersetzungsschl\u00FCssel f\u00FCr die Anzahl\n     * @param entryMsg Der \u00DCbersetzungsschl\u00FCssel f\u00FCr jeden Eintrag\n     */\n    protected logConfigs(configs: T[], countMsg: string, entryMsg: string): void {\n        this.adapter.log.info(this.adapter.library.translate(countMsg, configs.length));\n        for (const config of configs) {\n            this.adapter.log.info(\n                this.adapter.library.translate(entryMsg, config.customName || config.name || '', config.id ?? ''),\n            );\n        }\n    }\n\n    /**\n     * Abstrakte Methode f\u00FCr die eigentliche Abfrage - muss von Subklassen implementiert werden.\n     */\n    protected abstract queryConfig(config: T, service: ITransportService): Promise<boolean>;\n\n    /**\n     * F\u00FChrt Abfragen f\u00FCr alle Konfigurationen durch.\n     *\n     * @param configs Die Konfigurationen\n     * @param service Der Transport-Service\n     * @param fetchingMsg Der \u00DCbersetzungsschl\u00FCssel f\u00FCr \"Abrufen\"\n     * @param updatedMsg Der \u00DCbersetzungsschl\u00FCssel f\u00FCr \"Aktualisiert\"\n     * @param failedMsg Der \u00DCbersetzungsschl\u00FCssel f\u00FCr \"Fehlgeschlagen\"\n     * @returns Objekt mit successCount und errorCount\n     */\n    private async queryConfigs(\n        configs: T[],\n        service: ITransportService,\n        fetchingMsg: string,\n        updatedMsg: string,\n        failedMsg: string,\n    ): Promise<{ successCount: number; errorCount: number }> {\n        let successCount = 0;\n        let errorCount = 0;\n\n        for (const config of configs) {\n            if (!config.id) {\n                this.adapter.log.warn(\n                    this.adapter.library.translate('msg_stationNoValidId', config.customName || config.name || ''),\n                );\n                continue;\n            }\n\n            this.adapter.log.info(\n                this.adapter.library.translate(fetchingMsg, config.customName || config.name || '', config.id),\n            );\n\n            const success = await this.queryConfig(config, service);\n\n            if (success) {\n                successCount++;\n                this.adapter.log.info(\n                    this.adapter.library.translate(updatedMsg, config.customName || config.name || '', config.id),\n                );\n            } else {\n                errorCount++;\n                this.adapter.log.warn(\n                    this.adapter.library.translate(failedMsg, config.customName || config.name || '', config.id),\n                );\n            }\n        }\n\n        return { successCount, errorCount };\n    }\n\n    /**\n     * Startet das Polling.\n     *\n     * @param configs Die Konfigurationen\n     * @param pollIntervalMinutes Das Polling-Intervall in Minuten\n     * @param messages Die \u00DCbersetzungsschl\u00FCssel f\u00FCr verschiedene Meldungen\n     * @param messages.noConfig keine Konfigurationen vorhanden\n     * @param messages.noEnabled keine aktivierten Konfigurationen vorhanden\n     * @param messages.count Anzahl der aktiven Konfigurationen\n     * @param messages.entry Eintrag f\u00FCr jede Konfiguration\n     * @param messages.fetching Abrufen der Daten\n     * @param messages.updated Daten aktualisiert\n     * @param messages.failed Datenaktualisierung fehlgeschlagen\n     * @param messages.firstCompleted erste Abfrage abgeschlossen\n     * @param messages.queryCompleted Abfrage abgeschlossen\n     * @param messages.waiting Warten auf die n\u00E4chste Abfrage\n     */\n    public async start(\n        configs: T[] | undefined,\n        pollIntervalMinutes: number,\n        messages: {\n            noConfig: string;\n            noEnabled: string;\n            count: string;\n            entry: string;\n            fetching: string;\n            updated: string;\n            failed: string;\n            firstCompleted: string;\n            queryCompleted: string;\n            waiting: string;\n        },\n    ): Promise<void> {\n        const service = this.adapter.getActiveService();\n        const enabledConfigs = this.getEnabledConfigs(configs, messages.noConfig, messages.noEnabled);\n\n        if (!enabledConfigs) {\n            return;\n        }\n\n        this.logConfigs(enabledConfigs, messages.count, messages.entry);\n\n        const pollInterval = pollIntervalMinutes * 60 * 1000;\n\n        // Erste Abfrage sofort ausf\u00FChren\n        const { successCount, errorCount } = await this.queryConfigs(\n            enabledConfigs,\n            service,\n            messages.fetching,\n            messages.updated,\n            messages.failed,\n        );\n        this.adapter.log.info(this.adapter.library.translate(messages.firstCompleted, successCount, errorCount));\n        this.adapter.log.info(this.adapter.library.translate(messages.waiting, pollIntervalMinutes));\n\n        // Starte Intervall f\u00FCr regelm\u00E4\u00DFige Abfragen\n        this.pollInterval = this.adapter.setInterval(async () => {\n            const { successCount, errorCount } = await this.queryConfigs(\n                enabledConfigs,\n                service,\n                messages.fetching,\n                messages.updated,\n                messages.failed,\n            );\n            this.adapter.log.info(this.adapter.library.translate(messages.queryCompleted, successCount, errorCount));\n            this.adapter.log.info(this.adapter.library.translate(messages.waiting, pollIntervalMinutes));\n        }, pollInterval);\n    }\n\n    /**\n     * Stoppt das Polling.\n     */\n    public stop(): void {\n        if (this.pollInterval) {\n            clearInterval(this.pollInterval);\n            this.pollInterval = undefined;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["successCount", "errorCount"]
}
