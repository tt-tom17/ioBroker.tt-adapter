{
  "version": 3,
  "sources": ["../../../src/lib/class/station.ts"],
  "sourcesContent": ["import type * as Hafas from 'hafas-client';\nimport type { PublicTransport } from '../../main';\nimport { genericStateObjects } from '../const/definition';\nimport { BaseClass } from '../tools/library';\nimport { mapStationToStationState, mapStopToStopState } from '../tools/mapper';\nimport type { StationState, Stopstate } from '../types/types';\n\nexport class StationRequest extends BaseClass {\n    constructor(adapter: PublicTransport) {\n        super(adapter);\n        this.log.setLogPrefix('stationReq');\n    }\n\n    private isStation(station: Hafas.Station | Hafas.Stop): station is Hafas.Station {\n        return station.type === 'station';\n    }\n\n    /**\n     * Validiert, ob der initialisierte Client und das Profil mit dem angegebenen client_profile \u00FCbereinstimmen.\n     *\n     * @param client_profile Das erwartete Client-Profil (z.B. \"hafas:vbb\", \"vendo:db\")\n     * @throws Error wenn Client-Typ oder Profil nicht \u00FCbereinstimmen\n     */\n    private validateClientProfile(client_profile?: string): void {\n        if (!client_profile) {\n            return; // Keine Validierung wenn nicht angegeben\n        }\n\n        // Parse client_profile (z.B. \"hafas:vbb\" -> serviceType: \"hafas\", profile: \"vbb\")\n        const parts = client_profile.split(':');\n        const expectedServiceType = parts[0]; // 'hafas' oder 'vendo'\n        const expectedProfile = parts[1] || ''; // z.B. 'vbb', 'oebb', 'db'\n\n        // Pr\u00FCfe, ob der richtige Service-Typ initialisiert ist\n        const currentServiceType = this.adapter.config.serviceType || 'hafas';\n        if (currentServiceType !== expectedServiceType) {\n            throw new Error(\n                this.library.translate('msg_wrongClientType', expectedServiceType, currentServiceType, client_profile),\n            );\n        }\n\n        // Pr\u00FCfe das Profil (nur relevant bei HAFAS)\n        if (expectedServiceType === 'hafas' && expectedProfile) {\n            const currentProfile = this.adapter.config.profile || '';\n            if (currentProfile !== expectedProfile) {\n                throw new Error(\n                    this.library.translate('msg_wrongProfile', expectedProfile, currentProfile, client_profile),\n                );\n            }\n        }\n    }\n\n    /**\n     * Ruft Informationen einer Station anhand der stationId ab.\n     *\n     * @param stationId     Die ID der Station.\n     * @param service       Der Service f\u00FCr die Abfrage.\n     * @param options       Zus\u00E4tzliche Optionen f\u00FCr die Abfrage.\n     * @param client_profile Das Client-Profil f\u00FCr die Abfrage (z.B. \"hafas:vbb\", \"vendo:db\")\n     * @returns             Die Informationen der Station oder Haltestelle.\n     */\n    public async getStation(\n        stationId: string,\n        service: any,\n        options?: Hafas.StopOptions,\n        client_profile?: string,\n    ): Promise<Hafas.Station | Hafas.Stop> {\n        try {\n            if (!stationId) {\n                throw new Error(this.library.translate('msg_departureNoStationId'));\n            }\n            if (!service) {\n                throw new Error(this.library.translate('msg_noServices'));\n            }\n\n            // Validiere Client und Profil\n            this.validateClientProfile(client_profile);\n            const station: Hafas.Station | Hafas.Stop = await service.getStop(stationId, options);\n            // Vollst\u00E4ndiges JSON f\u00FCr Debugging\n            this.adapter.log.debug(JSON.stringify(station, null, 1));\n            return station;\n        } catch (err) {\n            this.log.error(this.library.translate('msg_stationQueryError', stationId, (err as Error).message));\n            throw err;\n        }\n    }\n\n    /**\n     * Schreibt die Stationsdaten in die States.\n     *\n     * @param basePath      Der Basis-Pfad f\u00FCr die States.\n     * @param stationData   Die Daten der Station oder Haltestelle.\n     */\n    public async writeStationData(basePath: string, stationData: Hafas.Station | Hafas.Stop): Promise<void> {\n        try {\n            await this.library.writedp(`${basePath}.json`, JSON.stringify(stationData), {\n                _id: 'nicht_definieren',\n                type: 'state',\n                common: {\n                    name: 'raw_station_data',\n                    type: 'string',\n                    role: 'json',\n                    read: true,\n                    write: false,\n                },\n                native: {},\n            });\n            if (this.isStation(stationData)) {\n                const stationState: StationState = mapStationToStationState(stationData);\n                // JSON in die States schreiben\n                await this.library.writeFromJson(`${basePath}`, 'station', genericStateObjects, stationState, true);\n            } else {\n                const stopState: Stopstate = mapStopToStopState(stationData);\n                await this.library.writeFromJson(`${basePath}`, 'station.stop', genericStateObjects, stopState, true);\n            }\n            // Vor dem Schreiben alte States l\u00F6schen\n            await this.library.garbageColleting(`${basePath}.`, 2000);\n        } catch (err) {\n            this.log.error(this.library.translate('msg_stationWriteError', (err as Error).message));\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,wBAAoC;AACpC,qBAA0B;AAC1B,oBAA6D;AAGtD,MAAM,uBAAuB,yBAAU;AAAA,EAC1C,YAAY,SAA0B;AAClC,UAAM,OAAO;AACb,SAAK,IAAI,aAAa,YAAY;AAAA,EACtC;AAAA,EAEQ,UAAU,SAA+D;AAC7E,WAAO,QAAQ,SAAS;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBAAsB,gBAA+B;AACzD,QAAI,CAAC,gBAAgB;AACjB;AAAA,IACJ;AAGA,UAAM,QAAQ,eAAe,MAAM,GAAG;AACtC,UAAM,sBAAsB,MAAM,CAAC;AACnC,UAAM,kBAAkB,MAAM,CAAC,KAAK;AAGpC,UAAM,qBAAqB,KAAK,QAAQ,OAAO,eAAe;AAC9D,QAAI,uBAAuB,qBAAqB;AAC5C,YAAM,IAAI;AAAA,QACN,KAAK,QAAQ,UAAU,uBAAuB,qBAAqB,oBAAoB,cAAc;AAAA,MACzG;AAAA,IACJ;AAGA,QAAI,wBAAwB,WAAW,iBAAiB;AACpD,YAAM,iBAAiB,KAAK,QAAQ,OAAO,WAAW;AACtD,UAAI,mBAAmB,iBAAiB;AACpC,cAAM,IAAI;AAAA,UACN,KAAK,QAAQ,UAAU,oBAAoB,iBAAiB,gBAAgB,cAAc;AAAA,QAC9F;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAa,WACT,WACA,SACA,SACA,gBACmC;AACnC,QAAI;AACA,UAAI,CAAC,WAAW;AACZ,cAAM,IAAI,MAAM,KAAK,QAAQ,UAAU,0BAA0B,CAAC;AAAA,MACtE;AACA,UAAI,CAAC,SAAS;AACV,cAAM,IAAI,MAAM,KAAK,QAAQ,UAAU,gBAAgB,CAAC;AAAA,MAC5D;AAGA,WAAK,sBAAsB,cAAc;AACzC,YAAM,UAAsC,MAAM,QAAQ,QAAQ,WAAW,OAAO;AAEpF,WAAK,QAAQ,IAAI,MAAM,KAAK,UAAU,SAAS,MAAM,CAAC,CAAC;AACvD,aAAO;AAAA,IACX,SAAS,KAAK;AACV,WAAK,IAAI,MAAM,KAAK,QAAQ,UAAU,yBAAyB,WAAY,IAAc,OAAO,CAAC;AACjG,YAAM;AAAA,IACV;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,iBAAiB,UAAkB,aAAwD;AACpG,QAAI;AACA,YAAM,KAAK,QAAQ,QAAQ,GAAG,QAAQ,SAAS,KAAK,UAAU,WAAW,GAAG;AAAA,QACxE,KAAK;AAAA,QACL,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AACD,UAAI,KAAK,UAAU,WAAW,GAAG;AAC7B,cAAM,mBAA6B,wCAAyB,WAAW;AAEvE,cAAM,KAAK,QAAQ,cAAc,GAAG,QAAQ,IAAI,WAAW,uCAAqB,cAAc,IAAI;AAAA,MACtG,OAAO;AACH,cAAM,gBAAuB,kCAAmB,WAAW;AAC3D,cAAM,KAAK,QAAQ,cAAc,GAAG,QAAQ,IAAI,gBAAgB,uCAAqB,WAAW,IAAI;AAAA,MACxG;AAEA,YAAM,KAAK,QAAQ,iBAAiB,GAAG,QAAQ,KAAK,GAAI;AAAA,IAC5D,SAAS,KAAK;AACV,WAAK,IAAI,MAAM,KAAK,QAAQ,UAAU,yBAA0B,IAAc,OAAO,CAAC;AAAA,IAC1F;AAAA,EACJ;AACJ;",
  "names": []
}
